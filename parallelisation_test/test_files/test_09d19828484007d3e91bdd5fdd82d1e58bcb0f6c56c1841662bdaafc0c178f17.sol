/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "remote_ino_prot.h"
#define MAX_REQ 9000
#define MAX_PATH 500
#include "xdr.h"

bool_t
myxdr_filepath(register XDR *xdrs, filepath *objp)
{

	if (!myxdr_string(xdrs, objp, MAX_PATH))
		return (FALSE);
	return (TRUE);
}

bool_t
myxdr_remino_callnum(register XDR *xdrs, remino_callnum *objp)
{

	if (!myxdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
myxdr_remino_open_args(register XDR *xdrs, remino_open_args *objp)
{

	if (!myxdr_filepath(xdrs, &objp->path))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->flags))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->mode))
		return (FALSE);
	return (TRUE);
}

bool_t
myxdr_remino_close_args(register XDR *xdrs, remino_close_args *objp)
{

	if (!myxdr_int(xdrs, &objp->fd))
		return (FALSE);
	return (TRUE);
}

bool_t
myxdr_remino_read_args(register XDR *xdrs, remino_read_args *objp)
{

	if (!myxdr_int(xdrs, &objp->fd))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->pos))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->len))
		return (FALSE);
	return (TRUE);
}

bool_t
myxdr_remino_write_args(register XDR *xdrs, remino_write_args *objp)
{

	if (!myxdr_int(xdrs, &objp->fd))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->pos))
		return (FALSE);
	if (!myxdr_bytes(xdrs, (uchar **)&objp->data.data_val, (u_int *) &objp->data.data_len, MAX_REQ))
		return (FALSE);
	return (TRUE);
}

bool_t
myxdr_remino_truncate_args(register XDR *xdrs, remino_truncate_args *objp)
{

	if (!myxdr_filepath(xdrs, &objp->path))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->length))
		return (FALSE);
	return (TRUE);
}

bool_t
myxdr_remino_path_args(register XDR *xdrs, remino_path_args *objp)
{

	if (!myxdr_filepath(xdrs, &objp->path))
		return (FALSE);
	return (TRUE);
}

bool_t
myxdr_remino_dirptr_args(register XDR *xdrs, remino_dirptr_args *objp)
{

	if (!myxdr_u_int(xdrs, &objp->dirptr))
		return (FALSE);
	return (TRUE);
}

bool_t
myxdr_remino_dirptr2_args(register XDR *xdrs, remino_dirptr2_args *objp)
{

	if (!myxdr_u_int(xdrs, &objp->dirptr))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->pos))
		return (FALSE);
	return (TRUE);
}

bool_t
myxdr_remino_path_mode_args(register XDR *xdrs, remino_path_mode_args *objp)
{

	if (!myxdr_filepath(xdrs, &objp->path))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->mode))
		return (FALSE);
	return (TRUE);
}

bool_t
myxdr_remino_rename_args(register XDR *xdrs, remino_rename_args *objp)
{

	if (!myxdr_filepath(xdrs, &objp->from))
		return (FALSE);
	if (!myxdr_filepath(xdrs, &objp->to))
		return (FALSE);
	return (TRUE);
}

bool_t
myxdr_remino_chown_args(register XDR *xdrs, remino_chown_args *objp)
{

	if (!myxdr_filepath(xdrs, &objp->path))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->owner))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->group))
		return (FALSE);
	return (TRUE);
}

bool_t
myxdr_remino_utimes_args(register XDR *xdrs, remino_utimes_args *objp)
{

	if (!myxdr_filepath(xdrs, &objp->path))
		return (FALSE);
	if (!myxdr_u_int(xdrs, &objp->asecs))
		return (FALSE);
	if (!myxdr_u_int(xdrs, &objp->ausecs))
		return (FALSE);
	if (!myxdr_u_int(xdrs, &objp->msecs))
		return (FALSE);
	if (!myxdr_u_int(xdrs, &objp->musecs))
		return (FALSE);
	return (TRUE);
}

bool_t
myxdr_remino_call(register XDR *xdrs, remino_call *objp)
{

	if (!myxdr_remino_callnum(xdrs, &objp->call))
		return (FALSE);
	switch (objp->call) {
	case OPEN:
		if (!myxdr_remino_open_args(xdrs, &objp->remino_call_u.open))
			return (FALSE);
		break;
	case CLOSE:
		if (!myxdr_remino_close_args(xdrs, &objp->remino_call_u.close))
			return (FALSE);
		break;
	case READ:
		if (!myxdr_remino_read_args(xdrs, &objp->remino_call_u.read))
			return (FALSE);
		break;
	case WRITE:
		if (!myxdr_remino_write_args(xdrs, &objp->remino_call_u.write))
			return (FALSE);
		break;
	case TRUNCATE:
		if (!myxdr_remino_truncate_args(xdrs, &objp->remino_call_u.truncate))
			return (FALSE);
		break;
	case UNLINK:
	case OPENDIR:
	case RMDIR:
	case LSTAT:
	case READLINK:
		if (!myxdr_remino_path_args(xdrs, &objp->remino_call_u.path_only))
			return (FALSE);
		break;
	case CLOSEDIR:
	case READDIR:
	case REWINDDIR:
		if (!myxdr_remino_dirptr_args(xdrs, &objp->remino_call_u.dirptr_only))
			return (FALSE);
		break;
	case READDIR2:
		if (!myxdr_remino_dirptr2_args(xdrs, &objp->remino_call_u.dirptr2))
			return (FALSE);
		break;
	case MKDIR:
	case CHMOD:
		if (!myxdr_remino_path_mode_args(xdrs, &objp->remino_call_u.path_mode))
			return (FALSE);
		break;
	case RENAME:
	case LINK_S:
	case LINK_H:
		if (!myxdr_remino_rename_args(xdrs, &objp->remino_call_u.rename))
			return (FALSE);
		break;
	case CHOWN:
		if (!myxdr_remino_chown_args(xdrs, &objp->remino_call_u.chown))
			return (FALSE);
		break;
	case UTIMES:
		if (!myxdr_remino_utimes_args(xdrs, &objp->remino_call_u.utimes))
			return (FALSE);
		break;
	default:
		break;
	}
	return (TRUE);
}

bool_t
myxdr_remino_open_reply(register XDR *xdrs, remino_open_reply *objp)
{

	if (!myxdr_int(xdrs, &objp->err))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->fd))
		return (FALSE);
	return (TRUE);
}

bool_t
myxdr_remino_errno_reply(register XDR *xdrs, remino_errno_reply *objp)
{

	if (!myxdr_int(xdrs, &objp->err))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->retval))
		return (FALSE);
	return (TRUE);
}

bool_t
myxdr_remino_read_reply(register XDR *xdrs, remino_read_reply *objp)
{

	if (!myxdr_int(xdrs, &objp->err))
		return (FALSE);
	if (!myxdr_bytes(xdrs, (uchar **)&objp->data.data_val, (u_int *) &objp->data.data_len, MAX_REQ))
		return (FALSE);
	return (TRUE);
}

bool_t
myxdr_remino_write_reply(register XDR *xdrs, remino_write_reply *objp)
{

	if (!myxdr_int(xdrs, &objp->err))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->size))
		return (FALSE);
	return (TRUE);
}

bool_t
myxdr_remino_opendir_reply(register XDR *xdrs, remino_opendir_reply *objp)
{

	if (!myxdr_int(xdrs, &objp->err))
		return (FALSE);
	if (!myxdr_u_int(xdrs, &objp->dirptr))
		return (FALSE);
	return (TRUE);
}

bool_t
myxdr_remino_readdir_entry(register XDR *xdrs, remino_readdir_entry *objp)
{

	if (!myxdr_int(xdrs, &objp->ftype))
		return (FALSE);
	if (!myxdr_filepath(xdrs, &objp->name))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->fileid))
		return (FALSE);
	return (TRUE);
}

bool_t
myxdr_remino_readdir_reply(register XDR *xdrs, remino_readdir_reply *objp)
{

	if (!myxdr_int(xdrs, &objp->err))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->retval))
		return (FALSE);
	if (!myxdr_remino_readdir_entry(xdrs, &objp->entry))
		return (FALSE);
	return (TRUE);
}

bool_t
myxdr_remino_stat_reply(register XDR *xdrs, remino_stat_reply *objp)
{

	if (!myxdr_int(xdrs, &objp->err))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->retval))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->mode))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->nlink))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->uid))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->gid))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->size))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->blocksize))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->rdev))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->blocks))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->fsid))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->asec))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->ausec))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->msec))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->musec))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->csec))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->cusec))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->fileid))
		return (FALSE);
	return (TRUE);
}

bool_t
myxdr_remino_readdir2_entry(register XDR *xdrs, remino_readdir2_entry *objp)
{

	if (!myxdr_remino_readdir_entry(xdrs, &objp->dirent))
		return (FALSE);
	if (!myxdr_remino_stat_reply(xdrs, &objp->stat))
		return (FALSE);
	if (!myxdr_pointer(xdrs, (uchar **)&objp->next, sizeof (remino_readdir2_entry), (xdrproc_t) myxdr_remino_readdir2_entry))
		return (FALSE);
	return (TRUE);
}

bool_t
myxdr_remino_readdir2_reply(register XDR *xdrs, remino_readdir2_reply *objp)
{

	if (!myxdr_int(xdrs, &objp->err))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->retval))
		return (FALSE);
	if (!myxdr_pointer(xdrs, (uchar **)&objp->list, sizeof (remino_readdir2_entry), (xdrproc_t) myxdr_remino_readdir2_entry))
		return (FALSE);
	if (!myxdr_bool(xdrs, &objp->eof))
		return (FALSE);
	return (TRUE);
}

bool_t
myxdr_remino_readlink_reply(register XDR *xdrs, remino_readlink_reply *objp)
{

	if (!myxdr_int(xdrs, &objp->err))
		return (FALSE);
	if (!myxdr_int(xdrs, &objp->retval))
		return (FALSE);
	if (!myxdr_filepath(xdrs, &objp->path))
		return (FALSE);
	return (TRUE);
}

bool_t
myxdr_remino_reply(register XDR *xdrs, remino_reply *objp)
{

	if (!myxdr_remino_callnum(xdrs, &objp->reply))
		return (FALSE);
	switch (objp->reply) {
	case OPEN:
		if (!myxdr_remino_open_reply(xdrs, &objp->remino_reply_u.open))
			return (FALSE);
		break;
	case CLOSE:
	case TRUNCATE:
	case UNLINK:
	case CLOSEDIR:
	case REWINDDIR:
	case MKDIR:
	case RMDIR:
	case RENAME:
	case CHOWN:
	case CHMOD:
	case UTIMES:
	case LINK_H:
	case LINK_S:
		if (!myxdr_remino_errno_reply(xdrs, &objp->remino_reply_u.err))
			return (FALSE);
		break;
	case READ:
		if (!myxdr_remino_read_reply(xdrs, &objp->remino_reply_u.read))
			return (FALSE);
		break;
	case WRITE:
		if (!myxdr_remino_write_reply(xdrs, &objp->remino_reply_u.write))
			return (FALSE);
		break;
	case OPENDIR:
		if (!myxdr_remino_opendir_reply(xdrs, &objp->remino_reply_u.opendir))
			return (FALSE);
		break;
	case READDIR:
		if (!myxdr_remino_readdir_reply(xdrs, &objp->remino_reply_u.readdir))
			return (FALSE);
		break;
	case READDIR2:
		if (!myxdr_remino_readdir2_reply(xdrs, &objp->remino_reply_u.readdir2))
			return (FALSE);
		break;
	case LSTAT:
		if (!myxdr_remino_stat_reply(xdrs, &objp->remino_reply_u.stat))
			return (FALSE);
		break;
	case READLINK:
		if (!myxdr_remino_readlink_reply(xdrs, &objp->remino_reply_u.readlink))
			return (FALSE);
		break;
	default:
		break;
	}
	return (TRUE);
}
